-----Structure and Interpretation of Computer Programs
(these notes will be recorded in analog first, then transcribed)

-to run scheme, startup emacs and M-x run-scheme

----Ch 1: Building Abstractions with Procedures
-Lisp was devlpd in '50s for reasoning with recursive logical expressions
-original paper: McCarthy 1960, "Recursive Functions of Symbolic Expressions and Their Computation by Machine"
-LISP = LISt Processing
-lisp is made of data objs called atoms and lists
-lisp description of procs are called 'procedures', and can of course be manipulated as data
-one lisp strength is blurring b/w passive data and active procs, and it can repr procs as data, making it excellent for manipulating OTHER programs as data [incl other langs?]

---Section 1.1: The Elements of Programming
-every language has 
-1. Primitive expressions - the simplest entities the language interacts with
-2. Means of combination - how compound elements are built from smaller ones
-3. Means of abstraction - how compound elements are named and manipulated
-the two kinds of elements are procs and data

--1.1.1 Expressions
-lisp uses an interpreter, and when you type in an EXPRESSION, it is EVALUATED
-basic math operators are primitive procedures in lisp
-combination of primitives is 
/e.g. (+ 137 349)
-expression delimiting (or, creating the boundaries of expressions) via
parentheses makes things called 'combinations'
-in above example, '+' is 'operator', and numbers are 'operands'
/the 'arguments' are the values of the operands
/uses 'prefix notation', which is weird until you see (+ 21 35 12 7)
/also allows easy nesting, e.g. (+ (* 3 5) (- 10 6))
$ -the interpreter always uses the same cycle: reads expr from terminal, evals
$ the expr, prints the result. This is called the 'read-eval-print-loop'
/note that you don't have to tell the interpreter to specifically print

--1.1.2 Naming and the Environment
-a 'name' IDs a 'variable' with a 'value' which is the 'object', e.g.
(define size 2)
/where 2 is the 'value' of the variable 'size'
-the mem by which the interpreter keeps track of name-obj pairs is the
'environment', or the 'global environment'

--1.1.3 Evaluating Combinations
-the interpreter:
/1. evalutes subexprs of the combo
/2. applies the procedure that happens to be the leftmost subexpr (operator) to
the values of the other subexprs (operands)
-recursively, to evaluate the combo, must first eval each part of the combo,eg
(* (+ 2 (* 4 6))
   (+ 3 5 7))
$ -this eval that uses 'percolate values upward' rules is aka 'tree accumulation'
/'percolate values upward' is a clear exa of recursion
$ -"the key point to notice is the role of the environ in determining the meaning of the symbols in exprs"
/in ch3, need to understand "the environ as providing context in which eval takes place", e.g. 'what exactly is represented by x, or even the operator +
$ -'define' is a special example of "special forms", since technically it is not treated as a operator-operand "combination"
/all special forms have their own eval rules

--1.1.4 Compound Procedures
-have shown numbers and math operations as primitive data and procs, nesting allows combination, and defns can provide a small lvl of abstraction
$ -next have "proc defns", wherein a compound defn can be given a name, eg
(define (square x) (* x x))
-gen form is (define (<name> <formal parameters>) <body>)
/where <name> is the name to be associated with it in the environ
-of course, can nest comp procs themselves, eg
(define (sum-of-squares x y)
  (+ (square x) (square y)))

--1.1.5 The Substitution Mdl for Proc Application
-When a combo's operator is a comp proc interpreter does same thing as if the operators were primitive procs
-can go through the "substitution mdl" of proc application
/this is to help think about proc app, not understand how the interpreter is working
/"in practice, the 'substitution' is accomplished by using a local env for formal params
-eventually, in ch5 will have gone through entirety of an interpreter and compiler?
-the "substitution mdl" is analagous to the simplest mdls in phys/engr, eg point mdls in physics
-in ch3 when bring up "mutable data", substitution mdl breaks down
--Applicative order vs. normal order
-normal order is "don't eval the operands until their values are needed"
/gives same answer as (f 5), but goes in different order, incl doing a few operations twice
-this is the same as FULL EXPANSION, and called normal-order eval
-"eval the arguments and then apply" is applicative-order evaluation
-for all procs that can be mdl'd using substitution, these sequence types make the same answer
/however, there are problems like Exercise 1.5 where this is not the case
-Lisp uses applicative-order eval, due to incr efficiency and normal-order get smuch more complicated for problems that can't be handled using substitution

--1.1.6 Conditional exprs and Predicates
-a test for cases, e.g. a simple absolute value test, is called a CASE ANALYSIS
-special Lisp form for case analyses is "cond", for conditional, e.g.
(define (abs x)
  (cond ((> x 0) x)
  	((= x 0) 0)
	((< x 0) (-x))))
-for (cond (<p_1> <e_1>)...), each p-e is a CLAUSE, p is a PREDICATE, e is CONSEQUENT EXPR
/each predicate from p_1 to p_2 on down is eval'd until a true value is found
/predicate can be proc or expr[incl code itself?]

-"if" is a special case of cond, wherein there are only two cases, e.g.
(if <predicate> <consequence> <ALTERNATIVE> )
/there's also
(and e_1 ... e_n) happens left to right
(or e_1 ... e_n) left to right
(not e) This is true when expr e is false.
$ -and and or are special forms, thus NOT procs, since not all subexprs are always eval'd
/not IS a regular proc
