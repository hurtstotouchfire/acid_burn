-----Structure and Interpretation of Computer Programs
(these notes will be recorded in analog first, then transcribed)

-to run scheme, startup emacs and M-x run-scheme

----Ch 1: Building Abstractions with Procedures
-Lisp was devlpd in '50s for reasoning with recursive logical expressions
-original paper: McCarthy 1960, "Recursive Functions of Symbolic Expressions and Their Computation by Machine"
-LISP = LISt Processing
-lisp is made of data objs called atoms and lists
-lisp description of procs are called 'procedures', and can of course be manipulated as data
-one lisp strength is blurring b/w passive data and active procs, and it can repr procs as data, making it excellent for manipulating OTHER programs as data [incl other langs?]

---Section 1.1: The Elements of Programming
-every language has 
-1. Primitive expressions - the simplest entities the language interacts with
-2. Means of combination - how compound elements are built from smaller ones
-3. Means of abstraction - how compound elements are named and manipulated
-the two kinds of elements are procs and data

--1.1.1 Expressions
-lisp uses an interpreter, and when you type in an EXPRESSION, it is EVALUATED
-basic math operators are primitive procedures in lisp
-combination of primitives is 
/e.g. (+ 137 349)
-expression delimiting (or, creating the boundaries of expressions) via
parentheses makes things called 'combinations'
-in above example, '+' is 'operator', and numbers are 'operands'
/the 'arguments' are the values of the operands
/uses 'prefix notation', which is weird until you see (+ 21 35 12 7)
/also allows easy nesting, e.g. (+ (* 3 5) (- 10 6))
$ -the interpreter always uses the same cycle: reads expr from terminal, evals
$ the expr, prints the result. This is called the 'read-eval-print-loop'
/note that you don't have to tell the interpreter to specifically print

--1.1.2 Naming and the Environment
-a 'name' IDs a 'variable' with a 'value' which is the 'object', e.g.
(define size 2)
/where 2 is the 'value' of the variable 'size'
-the mem by which the interpreter keeps track of name-obj pairs is the
'environment', or the 'global environment'

--1.1.3 Evaluating Combinations
-the interpreter:
/1. evalutes subexprs of the combo
/2. applies the procedure that happens to be the leftmost subexpr (operator) to
the values of the other subexprs (operands)
-recursively, to evaluate the combo, must first eval each part of the combo,eg
(* (+ 2 (* 4 6))
   (+ 3 5 7))
$ -this eval that uses 'percolate values upward' rules is aka 'tree accumulation'
/'percolate values upward' is a clear exa of recursion
$ -"the key point to notice is the role of the environ in determining the meaning of the symbols in exprs"
/in ch3, need to understand "the environ as providing context in which eval takes place", e.g. 'what exactly is represented by x, or even the operator +
$ -'define' is a special example of "special forms", since technically it is not treated as a operator-operand "combination"
/all special forms have their own eval rules

--1.1.4 Compound Procedures
-have shown numbers and math operations as primitive data and procs, nesting allows combination, and defns can provide a small lvl of abstraction
$ -next have "proc defns", wherein a compound defn can be given a name, eg
(define (square x) (* x x))
-gen form is (define (<name> <formal parameters>) <body>)
/where <name> is the name to be associated with it in the environ
-of course, can nest comp procs themselves, eg
(define (sum-of-squares x y)
  (+ (square x) (square y)))

--1.1.5 The Substitution Mdl for Proc Application
-When a combo's operator is a comp proc interpreter does same thing as if the operators were primitive procs
-can go through the "substitution mdl" of proc application
/this is to help think about proc app, not understand how the interpreter is working
/"in practice, the 'substitution' is accomplished by using a local env for formal params
-eventually, in ch5 will have gone through entirety of an interpreter and compiler?
-the "substitution mdl" is analagous to the simplest mdls in phys/engr, eg point mdls in physics
-in ch3 when bring up "mutable data", substitution mdl breaks down
--Applicative order vs. normal order
-normal order is "don't eval the operands until their values are needed"
/gives same answer as (f 5), but goes in different order, incl doing a few operations twice
-this is the same as FULL EXPANSION, and called normal-order eval
-"eval the arguments and then apply" is applicative-order evaluation
-for all procs that can be mdl'd using substitution, these sequence types make the same answer
/however, there are problems like Exercise 1.5 where this is not the case
-Lisp uses applicative-order eval, due to incr efficiency and normal-order get smuch more complicated for problems that can't be handled using substitution

-exa normal order, break everything down to primitive expressions? 
-"don't evalute the operands until their values are needed" aka "fully expand and reduce", way less efficient
(sum-of-squares (+ 5 1)                 (* 5 2)) = 
(+              (square (+ 5 1))        (square (* 5 2))) = 
(+              (* (+ 5 1) (+ 5 1))     (* (* 5 2) (* 5 2))) = actual evaluation:
(+              (* 6 6 )                (* 10 10))
(+              36                      100)
136
-exa applicative order, which is what the interpreter actually uses
-applicative is, when it encounters a primitive expression, even if the subfunctions aren't evaluated, the (possibly) primitive expression is evaluated and then fed into successive subfunctions as necessary
-can think of it as evaluating a primitive expression as first in the order of operations?
(sum-of-squares (+ 5 1) (* 5 2)) = 
(+ (square 6) (square 10)) =
(+ (* 6 6) (* 10 10)) = 
(+ 36 100) = 136

-"We noted that Scheme is an applicative-order language, namely, that all the arguments to Scheme procedures are evaluated when the procedure is applied. In contrast, normal-order languages delay evaluation of procedure arguments until the actual argument values are needed. Delaying evaluation of procedure arguments until the last possible moment (e.g., until they are required by a primitive operation) is called lazy evaluation."
-w/ lazy eval aka normal-order, if you give Scheme a true statement and then have something nonsenical in the 'else' case, the else is never evaluated because it is never the case. With applicative-order, which is what Scheme uses, even if you have an 'else' case that is never actually the case (so to speak), when you first give the expression, the else case will attempt to be evaluated for future use, causing your program to screw up.


--1.1.6 Conditional exprs and Predicates
-a test for cases, e.g. a simple absolute value test, is called a CASE ANALYSIS
-special Lisp form for case analyses is "cond", for conditional, e.g.
(define (abs x)
  (cond ((> x 0) x)
  	((= x 0) 0)
	((< x 0) (-x))))
-for (cond (<p_1> <e_1>)...), each p-e is a CLAUSE, p is a PREDICATE, e is CONSEQUENT EXPR
/each predicate from p_1 to p_2 on down is eval'd until a true value is found
/predicate can be proc or expr[incl code itself?]

-"if" is a special case of cond, wherein there are only two cases, e.g.
(if <predicate> <consequence> <ALTERNATIVE> )
/there's also
(and e_1 ... e_n) happens left to right
(or e_1 ... e_n) left to right
(not e) This is true when expr e is false.
$ -and and or are special forms, thus NOT procs, since not all subexprs are always eval'd
/not IS a regular proc
